"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.postcss = exports.sortAtomicStyleSheet = void 0;
const sort_pseudo_selectors_1 = require("../utils/sort-pseudo-selectors");
const parse_media_query_1 = require("./at-rules/parse-media-query");
const sort_at_rules_1 = require("./at-rules/sort-at-rules");
const sort_shorthand_declarations_1 = require("./sort-shorthand-declarations");
const sortAtRulePseudoSelectors = (atRule) => {
    const rules = [];
    atRule.each((childNode) => {
        switch (childNode.type) {
            case 'atrule':
                sortAtRulePseudoSelectors(childNode);
                break;
            case 'rule':
                rules.push(childNode.clone());
                childNode.remove();
                break;
            default:
                break;
        }
    });
    (0, sort_pseudo_selectors_1.sortPseudoSelectors)(rules);
    rules.forEach((rule) => {
        atRule.append(rule);
    });
};
/**
 * PostCSS plugin for sorting pseudo-selectors (inside and outside at-rules)
 * based on lvfha ordering, and the at-rules themselves as well.
 *
 * Only top level CSS rules will be sorted.
 *
 * Using Once due to the catchAll behaviour
 */
const sortAtomicStyleSheet = (config) => {
    var _a, _b;
    const sortAtRulesEnabled = (_a = config.sortAtRulesEnabled) !== null && _a !== void 0 ? _a : true;
    const sortShorthandEnabled = (_b = config.sortShorthandEnabled) !== null && _b !== void 0 ? _b : true;
    return {
        postcssPlugin: 'sort-atomic-style-sheet',
        Once(root) {
            const catchAll = [];
            const rules = [];
            const atRules = [];
            root.each((node) => {
                var _a;
                switch (node.type) {
                    case 'rule': {
                        if (((_a = node.first) === null || _a === void 0 ? void 0 : _a.type) === 'atrule') {
                            atRules.push({
                                parsed: sortAtRulesEnabled && node.first.name === 'media'
                                    ? (0, parse_media_query_1.parseMediaQuery)(node.first.params)
                                    : [],
                                node,
                                atRuleName: node.first.name,
                                query: node.first.params,
                            });
                        }
                        else {
                            rules.push(node);
                        }
                        break;
                    }
                    case 'atrule': {
                        atRules.push({
                            parsed: sortAtRulesEnabled && node.name === 'media' ? (0, parse_media_query_1.parseMediaQuery)(node.params) : [],
                            node,
                            atRuleName: node.name,
                            query: node.params,
                        });
                        break;
                    }
                    default: {
                        catchAll.push(node);
                    }
                }
            });
            if (sortShorthandEnabled) {
                (0, sort_shorthand_declarations_1.sortShorthandDeclarations)(catchAll);
                (0, sort_shorthand_declarations_1.sortShorthandDeclarations)(rules);
                (0, sort_shorthand_declarations_1.sortShorthandDeclarations)(atRules.map((atRule) => atRule.node));
            }
            // Pseudo-selector and at-rule sorting takes priority over shorthand
            // property sorting.
            (0, sort_pseudo_selectors_1.sortPseudoSelectors)(rules);
            if (sortAtRulesEnabled) {
                atRules.sort(sort_at_rules_1.sortAtRules);
            }
            for (const atRule of atRules) {
                const node = atRule.node;
                if (node.type !== 'atrule') {
                    continue;
                }
                sortAtRulePseudoSelectors(node);
            }
            root.nodes = [...catchAll, ...rules, ...atRules.map((atRule) => atRule.node)];
        },
    };
};
exports.sortAtomicStyleSheet = sortAtomicStyleSheet;
exports.postcss = true;
//# sourceMappingURL=sort-atomic-style-sheet.js.map