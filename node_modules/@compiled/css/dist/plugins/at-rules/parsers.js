"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseRangeSyntax = exports.parseReversedRangeSyntax = exports.parseMinMaxSyntax = void 0;
const REM_SIZE = 16;
function isPropertyValid(property) {
    return ['width', 'height', 'device-width', 'device-height'].includes(property);
}
function isComparisonOperatorValid(operator) {
    return ['<=', '=', '>=', '<', '>'].includes(operator);
}
const convertMinMaxMediaQuery = (match) => {
    var _a;
    const property = (_a = match.groups) === null || _a === void 0 ? void 0 : _a.property;
    switch (property) {
        case 'min-width':
        case 'min-device-width':
            // min-width: XYZ
            // is the same as
            // width >= XYZ
            return {
                property: property === 'min-width' ? 'width' : 'device-width',
                comparisonOperator: '>=',
            };
        case 'max-width':
        case 'max-device-width':
            // max-width: XYZ
            // is the same as
            // width <= XYZ
            return {
                property: property === 'max-width' ? 'width' : 'device-width',
                comparisonOperator: '<=',
            };
        case 'min-height':
        case 'min-device-height':
            return {
                property: property === 'min-height' ? 'height' : 'device-height',
                comparisonOperator: '>=',
            };
        case 'max-height':
        case 'max-device-height':
            return {
                property: property === 'max-height' ? 'height' : 'device-height',
                comparisonOperator: '<=',
            };
        case undefined:
            return;
        default:
            throw new SyntaxError(`Unexpected property '${property}' found when sorting media queries`);
    }
};
/**
 * This runs when we expect
 *
 *     <width|height> <comparisonOperator> <length>
 *
 * but we actually got
 *
 *     <length> <comparisonOperator> <width|height>
 *
 * So we need to normalise the comparison operator by reversing it.
 *
 * @param operator Comparison operator.
 * @returns The reversed comparison operator.
 */
const reverseComparisonOperator = (operator) => {
    switch (operator) {
        case '<':
            return '>';
        case '>':
            return '<';
        case '<=':
            return '>=';
        case '>=':
            return '<=';
        case '=':
            return '=';
    }
};
const getProperty = (match) => {
    var _a;
    const property = (_a = match.groups) === null || _a === void 0 ? void 0 : _a.property;
    if (property === undefined) {
        return;
    }
    if (isPropertyValid(property)) {
        return {
            property,
        };
    }
    throw new SyntaxError(`Unexpected property '${property}' found when sorting media queries.`);
};
const getOperator = (match, reverse, groupName = 'operator') => {
    var _a;
    const operator = (_a = match.groups) === null || _a === void 0 ? void 0 : _a[groupName];
    if (operator === undefined) {
        return;
    }
    if (isComparisonOperatorValid(operator)) {
        return {
            comparisonOperator: reverse === 'reverse' ? reverseComparisonOperator(operator) : operator,
        };
    }
    throw new SyntaxError(`Unexpected comparison operator '${operator}' found when sorting media queries.`);
};
const getLengthInfo = (match) => {
    var _a, _b;
    const length_ = (_a = match.groups) === null || _a === void 0 ? void 0 : _a.length;
    const lengthUnit = (_b = match.groups) === null || _b === void 0 ? void 0 : _b.lengthUnit;
    if (length_ === '0') {
        return { length: 0 };
    }
    if (typeof length_ !== 'string' || typeof lengthUnit !== 'string') {
        return undefined;
    }
    switch (lengthUnit) {
        case 'ch':
        case 'ex':
            // https://drafts.csswg.org/css-values/#font-relative-lengths
            // We assume 1ch and 1ex are 0.5em, as we cannot rely on more specific information here.
            return { length: +length_ * 0.5 * REM_SIZE };
        case 'em':
        case 'rem':
            return { length: +length_ * REM_SIZE };
        case 'px':
            return { length: +length_ };
        default:
            // This should never happen
            throw new Error(`Unrecognized length unit ${lengthUnit}. This is a Compiled bug!`);
    }
};
const getBasicMatchInfo = (match) => {
    if (!match.index) {
        return;
    }
    return { index: match.index, match: match[0] };
};
const parseMinMaxSyntax = (match) => {
    const basicMatchInfo = getBasicMatchInfo(match);
    const propertyAndOperatorInfo = convertMinMaxMediaQuery(match);
    const lengthInfo = getLengthInfo(match);
    if (basicMatchInfo && propertyAndOperatorInfo && lengthInfo) {
        return Object.assign(Object.assign(Object.assign({}, basicMatchInfo), propertyAndOperatorInfo), lengthInfo);
    }
    return;
};
exports.parseMinMaxSyntax = parseMinMaxSyntax;
const parseReversedRangeSyntax = (match) => {
    const basicMatchInfo = getBasicMatchInfo(match);
    const propertyInfo = getProperty(match);
    const operatorInfo = getOperator(match, 'reverse');
    const lengthInfo = getLengthInfo(match);
    if (basicMatchInfo && propertyInfo && operatorInfo && lengthInfo) {
        return Object.assign(Object.assign(Object.assign(Object.assign({}, basicMatchInfo), propertyInfo), operatorInfo), lengthInfo);
    }
    return;
};
exports.parseReversedRangeSyntax = parseReversedRangeSyntax;
const parseRangeSyntax = (match) => {
    const basicMatchInfo = getBasicMatchInfo(match);
    const propertyInfo = getProperty(match);
    const operatorInfo = getOperator(match, 'no-reverse');
    const lengthInfo = getLengthInfo(match);
    if (basicMatchInfo && propertyInfo && operatorInfo && lengthInfo) {
        return Object.assign(Object.assign(Object.assign(Object.assign({}, basicMatchInfo), propertyInfo), operatorInfo), lengthInfo);
    }
    return;
};
exports.parseRangeSyntax = parseRangeSyntax;
//# sourceMappingURL=parsers.js.map