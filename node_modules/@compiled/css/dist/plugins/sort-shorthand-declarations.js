"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sortShorthandDeclarations = void 0;
const utils_1 = require("@compiled/utils");
const nodeIsDeclaration = (node) => node.type === 'decl';
const findDeclaration = (node) => {
    if (nodeIsDeclaration(node)) {
        return node;
    }
    if ('nodes' in node) {
        // Return the first node that is a declaration, if we find one
        return node.nodes.find(nodeIsDeclaration);
    }
    return undefined;
};
const sortNodes = (a, b) => {
    var _a, _b;
    // NOTE: These return the first declaration when the class has multiple properties
    // eg. `-webkit-text-decoration:initial;text-decoration:initial` would sort
    // against `-webkit-text-decoration`, which may not be perfect in all cases
    const aDecl = findDeclaration(a);
    const bDecl = findDeclaration(b);
    // This will probably happen because we have an AtRule being compared to a regular
    // Rule. Don't try to sort this - the *contents* of the AtRule will be traversed and
    // sorted by sortShorthandDeclarations, and the sort-at-rules plugin will sort AtRules
    // so they come after regular rules.
    if (!(aDecl === null || aDecl === void 0 ? void 0 : aDecl.prop) || !(bDecl === null || bDecl === void 0 ? void 0 : bDecl.prop))
        return 0;
    // Why default to Infinity? Because if the property is not a shorthand property,
    // we want it to come after all of the other shorthand properties.
    const aShorthandBucket = (_a = utils_1.shorthandBuckets[aDecl.prop]) !== null && _a !== void 0 ? _a : Infinity;
    const bShorthandBucket = (_b = utils_1.shorthandBuckets[bDecl.prop]) !== null && _b !== void 0 ? _b : Infinity;
    // Ensures a deterministic sorting of shorthand properties in the case where those
    // shorthand properties overlap.
    //
    // For example, `border-top` and `border-color` are not shorthand properties of
    // each other, BUT both properties are shorthand versions of `border-top-color`.
    // If `border-top` is in bucket 4 and `border-color` is in bucket 2, we can ensure
    // that `border-color` always comes before `border-top`.
    return aShorthandBucket - bShorthandBucket;
};
const sortShorthandDeclarations = (nodes) => {
    if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length))
        return;
    // Recurse through nodes, eg. AtRules, Rules (psuedos, selectors) should also be sorted.
    nodes.forEach((node) => {
        var _a;
        if ('nodes' in node && ((_a = node.nodes) === null || _a === void 0 ? void 0 : _a.length)) {
            (0, exports.sortShorthandDeclarations)(node.nodes);
        }
    });
    nodes.sort(sortNodes);
};
exports.sortShorthandDeclarations = sortShorthandDeclarations;
//# sourceMappingURL=sort-shorthand-declarations.js.map