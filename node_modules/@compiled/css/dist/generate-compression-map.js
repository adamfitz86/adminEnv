"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateCompressionMap = void 0;
const postcss_1 = __importDefault(require("postcss"));
const postcss_selector_parser_1 = __importDefault(require("postcss-selector-parser"));
const class_name_generator_1 = require("./utils/class-name-generator");
const UNDERSCORE_UNICODE = 95;
/**
 * Generate a compression map, which is used by @compiled/babel-plugin to compress class names.
 * The compression map looks like { 'aaaabbbb': 'a', 'bbbbcccc': 'b' }
 *
 * @param stylesheet css content i.e. `.aaaabbbb{font-size: 10px}`
 * @param oldClassNameCompressionMap the previous compression map, which ensures the compression is deterministic.
 * @returns newClassNameCompressionMap
 */
const generateCompressionMap = (css, opts) => {
    const { oldClassNameCompressionMap, prefix } = opts || {};
    let classNamesToCompress = [];
    const classNameCompressionMap = {};
    const reservedClassNames = [];
    const selectorProcessor = (0, postcss_selector_parser_1.default)((selectors) => {
        selectors.walkClasses((node) => {
            // Only compress Atomic class names, which has the format of `_aaaabbbb`.
            if (node.value.charCodeAt(0) === UNDERSCORE_UNICODE && node.value.length === 9) {
                classNamesToCompress.push(node.value.slice(1));
            }
        });
    });
    const result = (0, postcss_1.default)([
        {
            postcssPlugin: 'postcss-find-atomic-class-names',
            Rule(ruleNode) {
                selectorProcessor.process(ruleNode);
            },
        },
    ]).process(css, { from: undefined });
    // We need to access something to make the transformation happen.
    result.css;
    // Remove duplicates
    classNamesToCompress = Array.from(new Set(classNamesToCompress));
    // Check if class name to compress already exists in oldClassNameCompressionMap
    // If yes, re-use the compressed class name
    if (oldClassNameCompressionMap) {
        classNamesToCompress = classNamesToCompress.filter((className) => {
            if (oldClassNameCompressionMap[className]) {
                reservedClassNames.push(oldClassNameCompressionMap[className]);
                classNameCompressionMap[className] = oldClassNameCompressionMap[className];
                return false;
            }
            return true;
        });
    }
    const classNameGenerator = new class_name_generator_1.ClassNameGenerator({ reservedClassNames, prefix });
    classNamesToCompress.forEach((className) => {
        const newClassName = classNameGenerator.generateClassName();
        classNameCompressionMap[className] = newClassName;
    });
    return classNameCompressionMap;
};
exports.generateCompressionMap = generateCompressionMap;
//# sourceMappingURL=generate-compression-map.js.map