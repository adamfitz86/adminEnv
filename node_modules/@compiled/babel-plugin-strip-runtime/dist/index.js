"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const path_1 = require("path");
const helper_plugin_utils_1 = require("@babel/helper-plugin-utils");
const template_1 = __importDefault(require("@babel/template"));
const t = __importStar(require("@babel/types"));
const css_1 = require("@compiled/css");
const utils_1 = require("@compiled/utils");
const is_automatic_runtime_1 = require("./utils/is-automatic-runtime");
const is_cc_component_1 = require("./utils/is-cc-component");
const is_create_element_1 = require("./utils/is-create-element");
const remove_style_declarations_1 = require("./utils/remove-style-declarations");
const to_uri_component_1 = require("./utils/to-uri-component");
exports.default = (0, helper_plugin_utils_1.declare)((api) => {
    api.assertVersion(7);
    return {
        name: '@compiled/babel-plugin-strip-runtime',
        pre() {
            this.styleRules = [];
        },
        visitor: {
            Program: {
                exit(path, { file, filename }) {
                    var _a, _b;
                    if (!filename) {
                        throw new Error(`@compiled/babel-plugin-strip-runtime expected the filename not to be empty, but actually got '${filename}'.`);
                    }
                    if (this.opts.compiledRequireExclude) {
                        // Rather than inserting styleRules to the code, inserting them to metadata in the case like SSR
                        if (!((_a = file.metadata) === null || _a === void 0 ? void 0 : _a.styleRules))
                            file.metadata.styleRules = [];
                        this.styleRules.forEach((rule) => {
                            file.metadata.styleRules.push(rule);
                        });
                        return;
                    }
                    if (this.opts.styleSheetPath) {
                        (0, utils_1.preserveLeadingComments)(path);
                        this.styleRules.forEach((rule) => {
                            // Each found atomic rule will create a new import that uses the styleSheetPath provided.
                            // The benefit is two fold:
                            // (1) thread safe collection of styles
                            // (2) caching -- resulting in faster builds (one import per rule!)
                            const params = (0, to_uri_component_1.toURIComponent)(rule);
                            path.unshiftContainer('body', template_1.default.ast(`require("${this.opts.styleSheetPath}?style=${params}");`));
                            // We use require instead of import so it works with both ESM and CJS source.
                            // If we used ESM it would blow up with CJS source, unfortunately.
                        });
                    }
                    if (this.opts.extractStylesToDirectory && this.styleRules.length > 0) {
                        // Build and sanitize filename of the css file
                        const cssFilename = `${(0, path_1.parse)(filename).name}.compiled.css`;
                        if (!((_b = file.opts.generatorOpts) === null || _b === void 0 ? void 0 : _b.sourceFileName)) {
                            throw new Error(`Source filename was not defined`);
                        }
                        const sourceFileName = file.opts.generatorOpts.sourceFileName;
                        if (!sourceFileName.includes(this.opts.extractStylesToDirectory.source)) {
                            throw new Error(`Source directory '${this.opts.extractStylesToDirectory.source}' was not found relative to source file ('${sourceFileName}')`);
                        }
                        // Get the path relative to the working directory
                        const relativePath = sourceFileName.slice(sourceFileName.indexOf(this.opts.extractStylesToDirectory.source) +
                            this.opts.extractStylesToDirectory.source.length);
                        // Write styles to sibling css file
                        const cssFilePath = (0, path_1.join)(this.cwd, this.opts.extractStylesToDirectory.dest, (0, path_1.dirname)(relativePath), cssFilename);
                        (0, fs_1.mkdirSync)((0, path_1.dirname)(cssFilePath), { recursive: true });
                        const sortConfig = {
                            sortAtRulesEnabled: this.opts.sortAtRules,
                            sortShorthandEnabled: this.opts.sortShorthand,
                        };
                        (0, fs_1.writeFileSync)(cssFilePath, (0, css_1.sort)(this.styleRules.sort().join('\n'), sortConfig));
                        // Add css import to file
                        path.unshiftContainer('body', t.importDeclaration([], t.stringLiteral(`./${cssFilename}`)));
                    }
                },
            },
            ImportSpecifier(path) {
                if (t.isIdentifier(path.node.imported) && ['CC', 'CS'].includes(path.node.imported.name)) {
                    path.remove();
                }
            },
            JSXElement(path, pass) {
                if (!t.isJSXIdentifier(path.node.openingElement.name)) {
                    return;
                }
                const componentName = path.node.openingElement.name.name;
                if (componentName !== 'CC') {
                    return;
                }
                const [, compiledStyles, , nodeToReplace] = path.get('children');
                // Before we replace this node with its children we need to go through and remove all the
                // style declarations from the CS call.
                (0, remove_style_declarations_1.removeStyleDeclarations)(compiledStyles.node, path, pass);
                if (t.isJSXExpressionContainer(nodeToReplace.node)) {
                    const container = nodeToReplace;
                    path.replaceWith(container.node.expression);
                }
                else {
                    path.replaceWith(nodeToReplace);
                }
                // All done! Let's replace this node with the user land child.
                path.node.leadingComments = null;
                return;
            },
            CallExpression(path, pass) {
                const callee = path.node.callee;
                if ((0, is_create_element_1.isCreateElement)(callee)) {
                    // We've found something that looks like React.createElement(...)
                    // Now we want to check if it's from the Compiled Runtime and if it is - replace with its children.
                    const component = path.node.arguments[0];
                    if (!(0, is_cc_component_1.isCCComponent)(component)) {
                        return;
                    }
                    const [, , compiledStyles, nodeToReplace] = path.get('arguments');
                    // Before we replace this node with its children we need to go through and remove all the
                    // style declarations from the CS call.
                    (0, remove_style_declarations_1.removeStyleDeclarations)(compiledStyles.node, path, pass);
                    // All done! Let's replace this node with the user land child.
                    path.node.leadingComments = null;
                    path.replaceWith(nodeToReplace);
                    return;
                }
                if ((0, is_automatic_runtime_1.isAutomaticRuntime)(path.node, 'jsxs')) {
                    // We've found something that looks like _jsxs(...)
                    // Now we want to check if it's from the Compiled Runtime and if it is - replace with its children.
                    const component = path.node.arguments[0];
                    if (!(0, is_cc_component_1.isCCComponent)(component)) {
                        return;
                    }
                    const [, props] = path.get('arguments');
                    if (!t.isObjectExpression(props.node)) {
                        return;
                    }
                    const children = props.node.properties.find((prop) => {
                        return (t.isObjectProperty(prop) && t.isIdentifier(prop.key) && prop.key.name === 'children');
                    });
                    if (!children || !t.isArrayExpression(children.value)) {
                        return;
                    }
                    const [compiledStyles, nodeToReplace] = children.value.elements;
                    if (!t.isExpression(nodeToReplace) || !t.isExpression(compiledStyles)) {
                        throw new Error('Nodes should be expressions.');
                    }
                    // Before we replace this node with its children we need to go through and remove all the
                    // style declarations from the CS call.
                    (0, remove_style_declarations_1.removeStyleDeclarations)(compiledStyles, path, pass);
                    // All done! Let's replace this node with the user land child.
                    path.node.leadingComments = null;
                    path.replaceWith(nodeToReplace);
                    return;
                }
            },
        },
    };
});
//# sourceMappingURL=index.js.map