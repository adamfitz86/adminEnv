"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("assert"));
const path_1 = require("path");
const css_1 = require("@compiled/css");
const utils_1 = require("@compiled/utils");
const plugin_1 = require("@parcel/plugin");
const posthtml_1 = __importDefault(require("posthtml"));
const posthtml_insert_at_1 = require("posthtml-insert-at");
const configFiles = [
    '.compiledcssrc',
    '.compiledcssrc.json',
    'compiledcss.js',
    'compiledcss.config.js',
];
exports.default = new plugin_1.Optimizer({
    async loadConfig({ config, options }) {
        const conf = await config.getConfigFrom((0, path_1.join)(options.projectRoot, 'index'), configFiles, {
            packageKey: '@compiled/parcel-optimizer',
        });
        const contents = {
            inlineCss: false,
            sortAtRules: true,
        };
        if (conf) {
            if (conf.filePath.endsWith('.js')) {
                config.invalidateOnStartup();
            }
            Object.assign(contents, conf.contents);
        }
        return contents;
    },
    async optimize({ contents, map, bundle, bundleGraph, options, config }) {
        const { outputFS } = options;
        const styleRules = new Set();
        // Traverse the descendants of HTML bundle
        // Extract the stylesRules from assets
        bundleGraph.traverseBundles((childBundle) => {
            childBundle.traverseAssets((asset) => {
                const rules = asset.meta.styleRules;
                if (rules == null) {
                    return;
                }
                (0, assert_1.default)(rules instanceof Array);
                for (const rule of rules) {
                    styleRules.add(rule);
                }
            });
        }, bundle);
        if (styleRules.size === 0)
            return { contents, map };
        const sortConfig = {
            sortAtRulesEnabled: config.sortAtRules,
            sortShorthandEnabled: config.sortShorthand,
        };
        const stylesheet = (0, css_1.sort)(Array.from(styleRules).join(''), sortConfig);
        let newContents = '';
        if (config.inlineCss) {
            newContents = (await (0, posthtml_1.default)()
                .use((0, posthtml_insert_at_1.insertAt)({
                selector: 'head',
                append: '<style>' + stylesheet + '</style>',
                behavior: 'inside',
            }))
                .process(contents.toString())).html;
        }
        else {
            const { distDir } = bundle.target;
            if (!outputFS.existsSync(distDir)) {
                await outputFS.mkdirp(distDir);
            }
            const cssFileName = (0, path_1.basename)(bundle.displayName, '.html') + '.' + (0, utils_1.hash)(stylesheet) + '.css';
            await outputFS.writeFile((0, path_1.join)(distDir, cssFileName), stylesheet, undefined // for TypeScript
            );
            newContents = (await (0, posthtml_1.default)()
                .use((0, posthtml_insert_at_1.insertAt)({
                selector: 'head',
                append: '<link href="' + bundle.target.publicUrl + cssFileName + '" rel="stylesheet" />',
                behavior: 'inside',
            }))
                .process(contents.toString())).html;
        }
        return { contents: newContents, map };
    },
});
//# sourceMappingURL=index.js.map