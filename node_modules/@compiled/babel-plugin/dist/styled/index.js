"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.visitStyledPath = void 0;
const t = __importStar(require("@babel/types"));
const ast_1 = require("../utils/ast");
const build_display_name_1 = require("../utils/build-display-name");
const build_styled_component_1 = require("../utils/build-styled-component");
const css_builders_1 = require("../utils/css-builders");
const createStyledDataPair = ({ tagName, tagType, cssNode, }) => ({
    tag: {
        name: tagName,
        type: tagType,
    },
    cssNode,
});
const extractStyledDataFromTemplateLiteral = (node, meta) => {
    var _a, _b, _c, _d;
    if (t.isMemberExpression(node.tag) &&
        t.isIdentifier(node.tag.object) &&
        ((_b = (_a = meta.state.compiledImports) === null || _a === void 0 ? void 0 : _a.styled) === null || _b === void 0 ? void 0 : _b.includes(node.tag.object.name)) &&
        t.isIdentifier(node.tag.property)) {
        const tagName = node.tag.property.name;
        const cssNode = node.quasi;
        return createStyledDataPair({ tagName, tagType: 'InBuiltComponent', cssNode });
    }
    if (t.isCallExpression(node.tag) &&
        t.isIdentifier(node.tag.callee) &&
        ((_d = (_c = meta.state.compiledImports) === null || _c === void 0 ? void 0 : _c.styled) === null || _d === void 0 ? void 0 : _d.includes(node.tag.callee.name)) &&
        t.isIdentifier(node.tag.arguments[0])) {
        const tagName = node.tag.arguments[0].name;
        const cssNode = node.quasi;
        return createStyledDataPair({ tagName, tagType: 'UserDefinedComponent', cssNode });
    }
    return undefined;
};
const extractStyledDataFromObjectLiteral = (node, meta) => {
    var _a, _b, _c, _d;
    if (t.isMemberExpression(node.callee) &&
        t.isIdentifier(node.callee.object) &&
        ((_b = (_a = meta.state.compiledImports) === null || _a === void 0 ? void 0 : _a.styled) === null || _b === void 0 ? void 0 : _b.includes(node.callee.object.name)) &&
        t.isExpression(node.arguments[0]) &&
        t.isIdentifier(node.callee.property)) {
        const tagName = node.callee.property.name;
        const cssNode = node.arguments;
        return createStyledDataPair({ tagName, tagType: 'InBuiltComponent', cssNode });
    }
    if (t.isCallExpression(node.callee) &&
        t.isIdentifier(node.callee.callee) &&
        ((_d = (_c = meta.state.compiledImports) === null || _c === void 0 ? void 0 : _c.styled) === null || _d === void 0 ? void 0 : _d.includes(node.callee.callee.name)) &&
        t.isExpression(node.arguments[0]) &&
        t.isIdentifier(node.callee.arguments[0])) {
        const tagName = node.callee.arguments[0].name;
        const cssNode = node.arguments;
        return createStyledDataPair({ tagName, tagType: 'UserDefinedComponent', cssNode });
    }
    return undefined;
};
/**
 * Interrogates `node` and returns styled data if any were found.
 * @param node
 */
const extractStyledDataFromNode = (node, meta) => {
    if (t.isTaggedTemplateExpression(node)) {
        return extractStyledDataFromTemplateLiteral(node, meta);
    }
    if (t.isCallExpression(node)) {
        return extractStyledDataFromObjectLiteral(node, meta);
    }
    return undefined;
};
/**
 * Check whether the node value includes an invalid CSS declaration.
 * This happens when a CSS property is defined with a conditional rule that doesn't specify a default value,
 * resulting in a node that has a CSS value without property ( eg. 'bold').
 *
 * Eg. font-weight: ${(props) => (props.isPrimary && props.isMaybe) && 'bold'}; should be converted
 * into ${(props) => props.isPrimary && props.isMaybe && ({ 'font-weight': 'bold' })};
 *
 * @param node
 */
const hasInValidExpression = (node) => {
    const logicalExpressions = node.quasi.expressions.filter((nodeExpression) => {
        return (t.isArrowFunctionExpression(nodeExpression) && t.isLogicalExpression(nodeExpression.body));
    });
    if (logicalExpressions.length === 0) {
        return false;
    }
    let invalidExpression = 0;
    node.quasi.quasis.forEach((item) => {
        const value = item.value.raw;
        const declarations = value.split(';');
        const l = declarations.length;
        for (let i = 0; i < l; i++) {
            const d = declarations[i];
            const css = d.substring(d.indexOf(':') + 1);
            // Check if the CSS declaration doesn't contain any value ( eg. '\n font-weight: ')
            if (d.includes(':') && !css.trim().length) {
                invalidExpression++;
                break;
            }
        }
    });
    return invalidExpression > 0;
};
/**
 * Takes a styled tagged template or call expression and then transforms it to a compiled component.
 *
 * `styled.div({})`
 *
 * @param path {NodePath} The tagged template or call expression
 * @param meta {Metadata} Useful metadata that can be used during the transformation
 */
const visitStyledPath = (path, meta) => {
    if (t.isTaggedTemplateExpression(path.node) && hasInValidExpression(path.node)) {
        throw (0, ast_1.buildCodeFrameError)(`A logical expression contains an invalid CSS declaration.
      Compiled doesn't support CSS properties that are defined with a conditional rule that doesn't specify a default value.
      Eg. font-weight: \${(props) => (props.isPrimary && props.isMaybe) && 'bold'}; is invalid.
      Use \${(props) => props.isPrimary && props.isMaybe && ({ 'font-weight': 'bold' })}; instead`, path.node, meta.parentPath);
    }
    const styledData = extractStyledDataFromNode(path.node, meta);
    if (!styledData) {
        // We didn't find a node we're interested in - bail out!
        return;
    }
    const cssOutput = (0, css_builders_1.buildCss)(styledData.cssNode, meta);
    path.replaceWith((0, build_styled_component_1.buildStyledComponent)(styledData.tag, cssOutput, meta));
    const parentVariableDeclaration = path.findParent((x) => x.isVariableDeclaration());
    if (parentVariableDeclaration && t.isVariableDeclaration(parentVariableDeclaration.node)) {
        const variableDeclarator = parentVariableDeclaration.node.declarations[0];
        if (t.isIdentifier(variableDeclarator.id)) {
            const variableName = variableDeclarator.id.name;
            parentVariableDeclaration.insertAfter((0, build_display_name_1.buildDisplayName)(variableName));
        }
    }
};
exports.visitStyledPath = visitStyledPath;
//# sourceMappingURL=index.js.map