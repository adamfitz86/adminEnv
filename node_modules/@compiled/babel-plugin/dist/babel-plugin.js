"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const helper_plugin_utils_1 = require("@babel/helper-plugin-utils");
const plugin_syntax_jsx_1 = __importDefault(require("@babel/plugin-syntax-jsx"));
const template_1 = __importDefault(require("@babel/template"));
const t = __importStar(require("@babel/types"));
const utils_1 = require("@compiled/utils");
const class_names_1 = require("./class-names");
const css_map_1 = require("./css-map");
const css_prop_1 = require("./css-prop");
const styled_1 = require("./styled");
const append_runtime_imports_1 = require("./utils/append-runtime-imports");
const ast_1 = require("./utils/ast");
const cache_1 = require("./utils/cache");
const is_compiled_1 = require("./utils/is-compiled");
const is_jsx_function_1 = require("./utils/is-jsx-function");
const normalize_props_usage_1 = require("./utils/normalize-props-usage");
const xcss_prop_1 = require("./xcss-prop");
// eslint-disable-next-line @typescript-eslint/no-var-requires
const packageJson = require('../package.json');
const JSX_SOURCE_ANNOTATION_REGEX = /\*?\s*@jsxImportSource\s+([^\s]+)/;
let globalCache;
const findClassicJsxPragmaImport = {
    ImportSpecifier(path, state) {
        const specifier = path.node;
        t.assertImportDeclaration(path.parent);
        // We don't care about other libraries
        if (!this.importSources.includes(path.parent.source.value))
            return;
        if ((specifier.imported.type === 'StringLiteral' && specifier.imported.value === 'jsx') ||
            (specifier.imported.type === 'Identifier' && specifier.imported.name === 'jsx')) {
            // Hurrah, we know that the jsx function in the JSX pragma refers to the
            // jsx function from Compiled.
            state.pragma.classicJsxPragmaIsCompiled = true;
            state.pragma.classicJsxPragmaLocalName = specifier.local.name;
            // Remove the jsx import; the assumption is that we removed the classic JSX pragma, so
            // Babel shouldn't convert React.createElement to the jsx function anymore.
            path.remove();
            return;
        }
    },
};
exports.default = (0, helper_plugin_utils_1.declare)((api) => {
    api.assertVersion(7);
    return {
        name: packageJson.name,
        inherits: plugin_syntax_jsx_1.default,
        pre(state) {
            var _a;
            const rootPath = (_a = state.opts.root) !== null && _a !== void 0 ? _a : this.cwd;
            this.sheets = {};
            this.cssMap = {};
            this.ignoreMemberExpressions = {};
            let cache;
            if (this.opts.cache === true) {
                globalCache = new cache_1.Cache();
                cache = globalCache;
            }
            else {
                cache = new cache_1.Cache();
            }
            cache.initialize(Object.assign(Object.assign({}, this.opts), { cache: !!this.opts.cache }));
            this.cache = cache;
            this.includedFiles = [];
            this.pathsToCleanup = [];
            this.pragma = {};
            this.usesXcss = false;
            this.importSources = [
                ...utils_1.DEFAULT_IMPORT_SOURCES,
                ...(this.opts.importSources
                    ? this.opts.importSources.map((origin) => {
                        if (origin[0] === '.') {
                            // We've found a relative path, transform it to be fully qualified.
                            return (0, path_1.join)(rootPath, origin);
                        }
                        return origin;
                    })
                    : []),
            ];
            if (typeof this.opts.resolver === 'object') {
                this.resolver = this.opts.resolver;
            }
            else if (typeof this.opts.resolver === 'string') {
                this.resolver = require(require.resolve(this.opts.resolver, {
                    paths: [rootPath],
                }));
            }
            this.transformCache = new WeakMap();
        },
        visitor: {
            Program: {
                enter(path, state) {
                    const { file } = state;
                    let jsxComment;
                    // Handle classic JSX pragma, if it exists
                    path.traverse(findClassicJsxPragmaImport, this);
                    if (!file.ast.comments) {
                        return;
                    }
                    for (const comment of file.ast.comments) {
                        const jsxSourceMatches = JSX_SOURCE_ANNOTATION_REGEX.exec(comment.value);
                        const jsxMatches = utils_1.JSX_ANNOTATION_REGEX.exec(comment.value);
                        // jsxPragmas currently only run on the top-level compiled module,
                        // hence we don't interrogate this.importSources.
                        if (jsxSourceMatches && this.importSources.includes(jsxSourceMatches[1])) {
                            // jsxImportSource pragma found - turn on CSS prop!
                            state.compiledImports = {};
                            state.pragma.jsxImportSource = true;
                            jsxComment = comment;
                        }
                        if (jsxMatches &&
                            state.pragma.classicJsxPragmaIsCompiled &&
                            jsxMatches[1] === state.pragma.classicJsxPragmaLocalName) {
                            state.compiledImports = {};
                            state.pragma.jsx = true;
                            jsxComment = comment;
                        }
                    }
                    if (jsxComment) {
                        // Delete the JSX pragma from the file, so that JSX
                        // elements don't get converted to jsx functions when using Compiled.
                        // This is to avoid having an import from a library that isn't
                        // `@compiled/react/runtime` in the final output:
                        //
                        //     import { jsx } from '@compiled/react'
                        //     import { jsx as _jsx } from '@compiled/react/jsx-runtime';
                        //     import { jsxs as _jsxs } from '@compiled/react/jsx-runtime';
                        // Hide the JSX pragma from the
                        // @babel/plugin-transform-react-jsx plugin
                        file.ast.comments = file.ast.comments.filter((c) => c !== jsxComment);
                        // Remove the JSX pragma comment from
                        // the Babel output.
                        //
                        // Note that Babel provides no way for us to traverse comments >:(
                        // So the best we can do is guess that the JSX pragma is probably at the start of the file.
                        if (path.node.body[0].leadingComments) {
                            path.node.body[0].leadingComments = path.node.body[0].leadingComments.filter((newComment) => newComment !== jsxComment);
                        }
                    }
                },
                exit(path, state) {
                    var _a, _b, _c;
                    if (!state.compiledImports && !state.usesXcss) {
                        return;
                    }
                    const { pragma } = state;
                    // Always import React if the developer is using
                    // /** @jsx jsx */, because these will get converted
                    // to React.createElement function calls
                    const shouldImportReact = state.pragma.jsx || ((_a = state.opts.importReact) !== null && _a !== void 0 ? _a : true);
                    (0, utils_1.preserveLeadingComments)(path);
                    (0, append_runtime_imports_1.appendRuntimeImports)(path, state);
                    if (!pragma.jsxImportSource && shouldImportReact && !path.scope.getBinding('React')) {
                        // React is missing - add it in at the last moment!
                        path.unshiftContainer('body', template_1.default.ast(`import * as React from 'react'`));
                    }
                    if (((_b = state.compiledImports) === null || _b === void 0 ? void 0 : _b.styled) && !path.scope.getBinding('forwardRef')) {
                        // forwardRef is missing - add it in at the last moment!
                        path.unshiftContainer('body', template_1.default.ast(`import { forwardRef } from 'react'`));
                    }
                    const filename = (0, path_1.basename)((_c = state.filename) !== null && _c !== void 0 ? _c : '') || 'File';
                    const version = process.env.TEST_PKG_VERSION || packageJson.version;
                    path.addComment('leading', ` ${filename} generated by ${packageJson.name} v${version} `);
                    // Add a line break after the comment
                    path.unshiftContainer('body', t.noop());
                    // Callback when included files have been added.
                    if (this.includedFiles.length && this.opts.onIncludedFiles) {
                        this.opts.onIncludedFiles((0, utils_1.unique)(this.includedFiles));
                    }
                    // Cleanup paths that have been marked.
                    state.pathsToCleanup.forEach((clean) => {
                        switch (clean.action) {
                            case 'remove': {
                                clean.path.remove();
                                return;
                            }
                            case 'replace': {
                                clean.path.replaceWith(t.nullLiteral());
                                return;
                            }
                            default:
                                return;
                        }
                    });
                },
            },
            ImportDeclaration(path, state) {
                const userLandModule = path.node.source.value;
                const isCompiledModule = this.importSources.some((compiledModuleOrigin) => {
                    if (compiledModuleOrigin === userLandModule) {
                        return true;
                    }
                    if (state.filename &&
                        userLandModule[0] === '.' &&
                        userLandModule.endsWith((0, path_1.basename)(compiledModuleOrigin))) {
                        // Relative import that might be a match, resolve the relative path and compare.
                        const fullpath = (0, path_1.resolve)((0, path_1.dirname)(state.filename), userLandModule);
                        return fullpath === compiledModuleOrigin;
                    }
                    return false;
                });
                if (!isCompiledModule) {
                    return;
                }
                // The presence of the module enables CSS prop
                state.compiledImports = state.compiledImports || {};
                // Go through each import and enable each found API
                path.get('specifiers').forEach((specifier) => {
                    if (!state.compiledImports || !specifier.isImportSpecifier()) {
                        // Bail out early
                        return;
                    }
                    ['styled', 'ClassNames', 'css', 'keyframes', 'cssMap'].forEach((apiName) => {
                        var _a, _b;
                        if (state.compiledImports &&
                            t.isIdentifier((_a = specifier.node) === null || _a === void 0 ? void 0 : _a.imported) &&
                            ((_b = specifier.node) === null || _b === void 0 ? void 0 : _b.imported.name) === apiName) {
                            // Enable the API with the local name
                            const apiArray = state.compiledImports[apiName] || [];
                            apiArray.push(specifier.node.local.name);
                            state.compiledImports[apiName] = apiArray;
                            specifier.remove();
                        }
                    });
                });
                if (path.node.specifiers.length === 0) {
                    path.remove();
                }
            },
            'TaggedTemplateExpression|CallExpression'(path, state) {
                if ((0, is_jsx_function_1.isTransformedJsxFunction)(path, state)) {
                    throw (0, ast_1.buildCodeFrameError)(`Found a \`jsx\` function call in the Babel output where one should not have been generated. Was Compiled not set up correctly?

Reasons this might happen:

[Likely] Importing \`jsx\` from a library other than Compiled CSS-in-JS - please only import from \`${utils_1.COMPILED_IMPORT}\`.

[Less likely] If you are using \`@babel/preset-react\` (or \`@babel/plugin-transform-react-jsx\`) in your Babel configuration, and you are using \`runtime: classic\`, make sure you do not use the \`pragma\` option. Please use the /** @jsx jsx */ syntax instead, or switch to \`runtime: automatic\``, 
                    // Use parent node to mitigate likelihood of
                    // "This is an error on an internal node." warning in the
                    // error output
                    path.parentPath.node, path.parentPath);
                }
                if ((0, is_compiled_1.isCompiledCSSMapCallExpression)(path.node, state)) {
                    (0, css_map_1.visitCssMapPath)(path, { context: 'root', state, parentPath: path });
                    return;
                }
                const hasStyles = (0, is_compiled_1.isCompiledCSSTaggedTemplateExpression)(path.node, state) ||
                    (0, is_compiled_1.isCompiledStyledTaggedTemplateExpression)(path.node, state) ||
                    (0, is_compiled_1.isCompiledCSSCallExpression)(path.node, state) ||
                    (0, is_compiled_1.isCompiledStyledCallExpression)(path.node, state);
                if (hasStyles) {
                    (0, normalize_props_usage_1.normalizePropsUsage)(path);
                }
                const isCompiledUtil = (0, is_compiled_1.isCompiledCSSTaggedTemplateExpression)(path.node, state) ||
                    (0, is_compiled_1.isCompiledKeyframesTaggedTemplateExpression)(path.node, state) ||
                    (0, is_compiled_1.isCompiledCSSCallExpression)(path.node, state) ||
                    (0, is_compiled_1.isCompiledKeyframesCallExpression)(path.node, state);
                if (isCompiledUtil) {
                    state.pathsToCleanup.push({ path, action: 'replace' });
                    return;
                }
                const isCompiledComponent = (0, is_compiled_1.isCompiledStyledTaggedTemplateExpression)(path.node, state) ||
                    (0, is_compiled_1.isCompiledStyledCallExpression)(path.node, state);
                if (isCompiledComponent) {
                    (0, styled_1.visitStyledPath)(path, { context: 'root', state, parentPath: path });
                    return;
                }
            },
            JSXElement(path, state) {
                var _a;
                if (!((_a = state.compiledImports) === null || _a === void 0 ? void 0 : _a.ClassNames)) {
                    return;
                }
                (0, class_names_1.visitClassNamesPath)(path, { context: 'root', state, parentPath: path });
            },
            JSXOpeningElement(path, state) {
                var _a;
                const compiledXCSSProp = (_a = state.opts.processXcss) !== null && _a !== void 0 ? _a : true;
                if (compiledXCSSProp) {
                    (0, xcss_prop_1.visitXcssPropPath)(path, { context: 'root', state, parentPath: path });
                }
                if (state.compiledImports) {
                    (0, css_prop_1.visitCssPropPath)(path, { context: 'root', state, parentPath: path });
                }
            },
        },
    };
});
//# sourceMappingURL=babel-plugin.js.map