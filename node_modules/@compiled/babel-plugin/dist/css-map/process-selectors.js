"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeExtendedSelectorsIntoProperties = void 0;
const t = __importStar(require("@babel/types"));
const ast_1 = require("../utils/ast");
const css_map_1 = require("../utils/css-map");
function* collapseAtRule(atRuleBlock, atRuleType, meta) {
    if (!t.isObjectExpression(atRuleBlock.value)) {
        throw (0, ast_1.buildCodeFrameError)((0, css_map_1.createErrorMessage)(css_map_1.ErrorMessages.AT_RULE_VALUE_TYPE), atRuleBlock.value, meta.parentPath);
    }
    for (const atRule of atRuleBlock.value.properties) {
        (0, css_map_1.errorIfNotValidObjectProperty)(atRule, meta);
        if (!(0, css_map_1.objectKeyIsLiteralValue)(atRule.key)) {
            throw (0, ast_1.buildCodeFrameError)((0, css_map_1.createErrorMessage)(css_map_1.ErrorMessages.STATIC_PROPERTY_KEY), atRule.key, meta.parentPath);
        }
        const atRuleName = `${atRuleType} ${(0, css_map_1.getKeyValue)(atRule.key)}`;
        const newKey = t.identifier(atRuleName);
        yield { atRuleName, atRuleValue: Object.assign(Object.assign({}, atRule), { key: newKey }) };
    }
}
const getExtendedSelectors = (variantStyles, meta) => {
    const extendedSelectorsFound = variantStyles.properties.filter((value) => t.isObjectProperty(value) && (0, css_map_1.hasExtendedSelectorsKey)(value));
    if (extendedSelectorsFound.length === 0)
        return [];
    if (extendedSelectorsFound.length > 1) {
        throw (0, ast_1.buildCodeFrameError)((0, css_map_1.createErrorMessage)(css_map_1.ErrorMessages.DUPLICATE_SELECTORS_BLOCK), extendedSelectorsFound[1], meta.parentPath);
    }
    const extendedSelectors = extendedSelectorsFound[0];
    if (!t.isObjectExpression(extendedSelectors.value)) {
        throw (0, ast_1.buildCodeFrameError)((0, css_map_1.createErrorMessage)(css_map_1.ErrorMessages.SELECTORS_BLOCK_VALUE_TYPE), extendedSelectors.value, meta.parentPath);
    }
    return extendedSelectors.value.properties;
};
/**
 * Given an object defined within an variant passed to `cssMap`, convert this object to
 * a less idiosyncratic form that can be directly processed by `buildCss`.
 *
 * For example, if our object is this:
 *
 *     {
 *       color: 'blue',
 *       '&:hover': {
 *         color: 'yellow',
 *       },
 *       '@media': {
 *         'screen and (min-width: 500px)': { ... }
 *         'screen and (min-width: 700px)': { ... }
 *       },
 *       selectors: {
 *         div: { color: 'orange' },
 *       }
 *     }
 *
 * This function will merge the two halves of the `@media` query (for example, to get
 * `@media screen and (min-width: 500px)`), and it will merge all of
 * the keys located in the value of `selectors`:
 *
 *     {
 *       color: 'blue',
 *       '&:hover': {
 *         color: 'yellow',
 *       },
 *       '@media screen and (min-width: 500px)': { ... }
 *       '@media screen and (max-width: 700px)': { ... }
 *       div: { color: 'orange' },
 *     }
 *
 * @param variantStyles an object expression representing the value of the cssMap variant
 * @param meta metadata from Babel, used for error messages
 * @returns the processed object expression
 */
const mergeExtendedSelectorsIntoProperties = (variantStyles, meta) => {
    const extendedSelectors = getExtendedSelectors(variantStyles, meta);
    const mergedProperties = [];
    const addedSelectors = new Set();
    for (const property of [...variantStyles.properties, ...extendedSelectors]) {
        // Covered by @compiled/eslint-plugin rule already,
        // this is just to make the type checker happy
        (0, css_map_1.errorIfNotValidObjectProperty)(property, meta);
        // Extract property.key into its own variable so we can do
        // type checking on it
        const propertyKey = property.key;
        if (!(0, css_map_1.objectKeyIsLiteralValue)(propertyKey)) {
            throw (0, ast_1.buildCodeFrameError)((0, css_map_1.createErrorMessage)(css_map_1.ErrorMessages.STATIC_PROPERTY_KEY), property.key, meta.parentPath);
        }
        if ((0, css_map_1.isPlainSelector)((0, css_map_1.getKeyValue)(propertyKey))) {
            throw (0, ast_1.buildCodeFrameError)((0, css_map_1.createErrorMessage)(css_map_1.ErrorMessages.USE_SELECTORS_WITH_AMPERSAND), property.key, meta.parentPath);
        }
        // we have already extracted the selectors object into the `extendedSelectors`
        // variable, so we can skip it now
        if ((0, css_map_1.hasExtendedSelectorsKey)(property))
            continue;
        if ((0, css_map_1.isAtRuleObject)(propertyKey)) {
            const atRuleType = (0, css_map_1.getKeyValue)(propertyKey);
            const atRules = collapseAtRule(property, atRuleType, meta);
            for (const { atRuleName, atRuleValue } of atRules) {
                if (addedSelectors.has(atRuleName)) {
                    throw (0, ast_1.buildCodeFrameError)((0, css_map_1.createErrorMessage)(css_map_1.ErrorMessages.DUPLICATE_AT_RULE), property.key, meta.parentPath);
                }
                mergedProperties.push(atRuleValue);
                addedSelectors.add(atRuleName);
            }
        }
        else {
            // If the property value is an object, we can be reasonably sure that
            // the key is a CSS selector and not a CSS property (this is just an
            // assumption, because we can never be 100% sure...)
            const isSelector = t.isObjectExpression(property.value);
            if (isSelector) {
                const isDuplicateSelector = addedSelectors.has((0, css_map_1.getKeyValue)(propertyKey));
                if (isDuplicateSelector) {
                    throw (0, ast_1.buildCodeFrameError)((0, css_map_1.createErrorMessage)(css_map_1.ErrorMessages.DUPLICATE_SELECTOR), property.key, meta.parentPath);
                }
                else {
                    addedSelectors.add((0, css_map_1.getKeyValue)(propertyKey));
                }
            }
            mergedProperties.push(property);
        }
    }
    return Object.assign(Object.assign({}, variantStyles), { properties: mergedProperties });
};
exports.mergeExtendedSelectorsIntoProperties = mergeExtendedSelectorsIntoProperties;
//# sourceMappingURL=process-selectors.js.map