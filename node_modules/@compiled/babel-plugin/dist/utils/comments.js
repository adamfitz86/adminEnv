"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNodeComments = void 0;
/**
 * Get comments for `path` in both the line before and on the current line.
 *
 * e.g.
 * `<div css={{color: 'green'}} /> // @compiled-disable-line` will output `{before: [], current: [...]}
 *
 * @param path {NodePath<t.Node>}
 * @param meta {Metadata} Context for the transform
 * @returns {before: t.CommentLine[], current: t.CommentLine[]} Comments before and on the current line as the input path
 */
const getNodeComments = (path, meta) => {
    var _a, _b, _c, _d, _e, _f;
    const lineNumber = (_b = (_a = path.node) === null || _a === void 0 ? void 0 : _a.loc) === null || _b === void 0 ? void 0 : _b.start.line;
    if (!lineNumber || lineNumber !== ((_d = (_c = path.node) === null || _c === void 0 ? void 0 : _c.loc) === null || _d === void 0 ? void 0 : _d.end.line)) {
        return { before: [], current: [] };
    }
    const file = meta.state.file;
    const commentLines = (_f = (_e = file.ast.comments) === null || _e === void 0 ? void 0 : _e.filter((comment) => comment.type === 'CommentLine')) !== null && _f !== void 0 ? _f : [];
    return {
        before: commentLines.filter((comment) => { var _a; return ((_a = comment.loc) === null || _a === void 0 ? void 0 : _a.start.line) === lineNumber - 1 && comment.loc.end.line === lineNumber - 1; }),
        current: commentLines.filter((comment) => { var _a; return ((_a = comment.loc) === null || _a === void 0 ? void 0 : _a.start.line) === lineNumber && comment.loc.end.line === lineNumber; }),
    };
};
exports.getNodeComments = getNodeComments;
//# sourceMappingURL=comments.js.map