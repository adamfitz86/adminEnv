import * as t from '@babel/types';
import type { Metadata } from '../../../types';
import { createResultPair } from '../../create-result-pair';
import type { EvaluateExpression } from '../../types';
/**
 * Will look in an expression and return the actual value along with updated metadata.
 *
 * E.g: If there is a member expression called `colors.primary` that has identifier `color` which
 * is set somewhere as `const colors = { primary: 'blue' }`,
 * passing the `colors` identifier to this function would return `'blue'`.
 *
 * @param expression Expression we want to interrogate.
 * @param meta {Metadata} Useful metadata that can be used during the transformation
 */
export declare const traverseMemberExpression: (expression: t.MemberExpression, meta: Metadata, evaluateExpression: EvaluateExpression) => ReturnType<typeof createResultPair>;
