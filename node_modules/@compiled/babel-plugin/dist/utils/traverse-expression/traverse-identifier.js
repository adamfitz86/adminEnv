"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.traverseIdentifier = void 0;
const create_result_pair_1 = require("../create-result-pair");
const resolve_binding_1 = require("../resolve-binding");
/**
 * Will look in an expression and return the actual value along with updated metadata.
 *
 * E.g: If there is an identifier called `color` that is set somewhere as `const color = 'blue'`,
 * passing the `color` identifier to this function would return `'blue'`.
 *
 * @param expression Expression we want to interrogate.
 * @param meta {Metadata} Useful metadata that can be used during the transformation
 */
const traverseIdentifier = (expression, meta, evaluateExpression) => {
    let value = undefined;
    let updatedMeta = meta;
    const resolvedBinding = (0, resolve_binding_1.resolveBinding)(expression.name, updatedMeta, evaluateExpression);
    if (resolvedBinding && resolvedBinding.constant && resolvedBinding.node) {
        // We recursively call get interpolation until it not longer returns an identifier or member expression
        ({ value, meta: updatedMeta } = evaluateExpression(resolvedBinding.node, resolvedBinding.meta));
    }
    return (0, create_result_pair_1.createResultPair)(value, updatedMeta);
};
exports.traverseIdentifier = traverseIdentifier;
//# sourceMappingURL=traverse-identifier.js.map