import * as t from '@babel/types';
import type { Metadata } from '../../types';
import { createResultPair } from '../create-result-pair';
import type { EvaluateExpression } from '../types';
/**
 * Will find the function node for the call expression and wrap an IIFE around it (to avoid name collision)
 * and move all the parameters mapped to passed arguments in the IIFE's scope (own scope in this case).
 * It will also set own scope path so that when we recursively evaluate any node,
 * we will look for its binding in own scope first, then parent scope.
 *
 * @param expression Expression we want to interrogate.
 * @param meta {Metadata} Useful metadata that can be used during the transformation
 */
export declare const traverseCallExpression: (expression: t.CallExpression, meta: Metadata, evaluateExpression: EvaluateExpression) => ReturnType<typeof createResultPair>;
