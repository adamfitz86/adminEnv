"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildCompiledComponent = exports.compiledTemplate = void 0;
const t = __importStar(require("@babel/types"));
const build_css_variables_1 = require("./build-css-variables");
const get_jsx_attribute_1 = require("./get-jsx-attribute");
const get_runtime_class_name_library_1 = require("./get-runtime-class-name-library");
const hoist_sheet_1 = require("./hoist-sheet");
const transform_css_items_1 = require("./transform-css-items");
const WHITESPACE_TEXT_NODES = {
    leading: t.jsxText('\n  '),
    trailing: t.jsxText('\n'),
};
/**
 * Will return a generated AST for a Compiled Component.
 * This is primarily used for CSS prop and ClassNames apis.
 *
 * @param node Originating node
 * @param sheets {string[]} Stylesheets
 * @param meta {Metadata} Useful metadata that can be used during the transformation
 */
const compiledTemplate = (node, sheets, meta) => {
    const nonce = meta.state.opts.nonce;
    const nonceAttribute = nonce
        ? t.jsxAttribute(t.jsxIdentifier('nonce'), t.jsxExpressionContainer(t.identifier(nonce)))
        : null;
    const [keyAttribute] = (0, get_jsx_attribute_1.getJSXAttribute)(node, 'key');
    return t.jsxElement(t.jsxOpeningElement(t.jsxIdentifier('CC'), keyAttribute ? [t.jsxAttribute(t.jsxIdentifier('key'), keyAttribute.value)] : [], false), t.jsxClosingElement(t.jsxIdentifier('CC')), [
        WHITESPACE_TEXT_NODES.leading,
        t.jsxElement(t.jsxOpeningElement(t.jsxIdentifier('CS'), nonceAttribute ? [nonceAttribute] : [], false), t.jsxClosingElement(t.jsxIdentifier('CS')), [
            t.jsxExpressionContainer(t.arrayExpression(Array.from(new Set(sheets)).map((sheet) => (0, hoist_sheet_1.hoistSheet)(sheet, meta)))),
        ]),
        WHITESPACE_TEXT_NODES.leading,
        t.jsxExpressionContainer(node),
        WHITESPACE_TEXT_NODES.trailing,
    ]);
};
exports.compiledTemplate = compiledTemplate;
/**
 * Returns the actual value of a jsx value.
 *
 * @param node
 */
const getExpression = (node) => {
    const value = t.isJSXExpressionContainer(node) ? node.expression : node;
    if (t.isJSXEmptyExpression(value)) {
        throw new Error('Empty expression not supported.');
    }
    return value;
};
/**
 * Returns a Compiled Component AST.
 *
 * @param node Originating node
 * @param cssOutput CSS and variables to place onto the component
 * @param meta {Metadata} Useful metadata that can be used during the transformation
 */
const buildCompiledComponent = (node, cssOutput, meta) => {
    const { sheets, classNames } = (0, transform_css_items_1.transformCssItems)(cssOutput.css, meta);
    const [classNameAttribute] = (0, get_jsx_attribute_1.getJSXAttribute)(node, 'className');
    if (classNameAttribute && classNameAttribute.value) {
        // If there is a class name prop statically defined we want to concatenate it with
        // the class name we're going to put on it.
        const classNameExpression = getExpression(classNameAttribute.value);
        const values = classNames.concat(classNameExpression);
        classNameAttribute.value = t.jsxExpressionContainer(t.callExpression(t.identifier((0, get_runtime_class_name_library_1.getRuntimeClassNameLibrary)(meta)), [t.arrayExpression(values)]));
    }
    else {
        // No class name - just push our own one.
        node.openingElement.attributes.push(t.jsxAttribute(t.jsxIdentifier('className'), t.jsxExpressionContainer(t.callExpression(t.identifier((0, get_runtime_class_name_library_1.getRuntimeClassNameLibrary)(meta)), [
            t.arrayExpression(classNames),
        ]))));
    }
    if (cssOutput.variables.length) {
        const [styleAttribute, styleAttributeIndex] = (0, get_jsx_attribute_1.getJSXAttribute)(node, 'style');
        const dynamicStyleProperties = (0, build_css_variables_1.buildCssVariables)(cssOutput.variables);
        if (styleAttribute) {
            // Remove the pre-existing style prop - we're going to redefine it soon.
            node.openingElement.attributes.splice(styleAttributeIndex, 1);
            if (styleAttribute.value &&
                t.isJSXExpressionContainer(styleAttribute.value) &&
                !t.isJSXEmptyExpression(styleAttribute.value.expression)) {
                // If it's not an object we just spread the expression into the object
                if (!t.isObjectExpression(styleAttribute.value.expression)) {
                    dynamicStyleProperties.splice(0, 0, t.spreadElement(styleAttribute.value.expression));
                }
                else {
                    // Else it's an object! So we want to place each property into the object
                    styleAttribute.value.expression.properties.forEach((prop, index) => {
                        if (t.isObjectMethod(prop)) {
                            return;
                        }
                        // We want to keep the order that they were defined in.
                        // So we're using index here to do just that.
                        dynamicStyleProperties.splice(index, 0, prop);
                    });
                }
            }
        }
        // Finally add the new style prop back to the opening JSX element.
        node.openingElement.attributes.push(t.jsxAttribute(t.jsxIdentifier('style'), t.jsxExpressionContainer(t.objectExpression(dynamicStyleProperties))));
    }
    return (0, exports.compiledTemplate)(node, sheets, meta);
};
exports.buildCompiledComponent = buildCompiledComponent;
//# sourceMappingURL=build-compiled-component.js.map