import type { NodePath } from '@babel/traverse';
import * as t from '@babel/types';
/**
 * Returns the nodes path including the scope of a parent.
 * @param node
 * @param parentPath
 */
export declare const getPathOfNode: (node: t.Node, parentPath: NodePath) => NodePath;
/**
 * Builds a code frame error from a passed in node.
 *
 * @param error
 * @param node
 * @param parentPath
 */
export declare const buildCodeFrameError: (error: string, node: t.Node | null, parentPath: NodePath<any>) => Error;
/**
 * Will wrap BlockStatement or Expression in an IIFE,
 * Looks like (() => { return 10; })().
 *
 * @param node Node of type either BlockStatement or Expression
 */
export declare const wrapNodeInIIFE: (node: t.BlockStatement | t.Expression) => t.CallExpression;
/**
 * Will pick `Function` body and tries to wrap it in an IIFE if
 * its a BlockStatement otherwise returns the picked body,
 * E.g.
 * `props => props.color` would end up as `props.color`.
 * `props => { return props.color; }` would end up as `(() => { return props.color })()`
 * `function () { return props.color; }` would end up as `(function () { return props.color })()`
 *
 * @param node Node of type ArrowFunctionExpression
 */
export declare const pickFunctionBody: (node: t.Function) => t.Expression;
