"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildStyledComponent = void 0;
const generator_1 = __importDefault(require("@babel/generator"));
const template_1 = __importDefault(require("@babel/template"));
const t = __importStar(require("@babel/types"));
const css_1 = require("@compiled/css");
const utils_1 = require("@compiled/utils");
const is_prop_valid_1 = __importDefault(require("@emotion/is-prop-valid"));
const constants_1 = require("../constants");
const ast_1 = require("./ast");
const build_css_variables_1 = require("./build-css-variables");
const compress_class_names_for_runtime_1 = require("./compress-class-names-for-runtime");
const css_builders_1 = require("./css-builders");
const get_runtime_class_name_library_1 = require("./get-runtime-class-name-library");
const hoist_sheet_1 = require("./hoist-sheet");
const transform_css_items_1 = require("./transform-css-items");
/**
 * Builds up the inline style prop value for a Styled Component.
 *
 * @param variables CSS variables that will be placed in the AST
 */
const styledStyleProp = (variables) => {
    const props = [
        t.spreadElement(t.identifier(constants_1.STYLE_IDENTIFIER_NAME)),
    ];
    return t.objectExpression(props.concat((0, build_css_variables_1.buildCssVariables)(variables, (node) => 
    // Allows us to use component's closure scope instead of arrow function
    t.isArrowFunctionExpression(node) ? (0, ast_1.pickFunctionBody)(node) : node)));
};
/**
 * Returns a tag string in the form of an identifier or string literal.
 *
 * A type of InBuiltComponent will return a string literal,
 * otherwise an identifier string will be returned.
 *
 * @param tag Made of name and type.
 */
const buildComponentTag = ({ name, type }) => {
    return type === 'InBuiltComponent' ? `"${name}"` : name;
};
const invalidDomPropsVisitor = {
    MemberExpression(path) {
        const { node: { object, property }, } = path;
        if (t.isIdentifier(object, { name: constants_1.PROPS_IDENTIFIER_NAME }) && t.isIdentifier(property)) {
            const { name } = property;
            if (name !== 'children' && !(0, is_prop_valid_1.default)(name)) {
                this.invalids.add(name);
            }
        }
    },
};
/**
 * Finds all prop usage in a component and returns a list
 * of props that are not valid HTML attributes
 *
 * @param path Path of the styled component.
 */
const getInvalidDomProps = (path) => {
    const state = { invalids: new Set() };
    path.traverse(invalidDomPropsVisitor, state);
    return Array.from(state.invalids);
};
/**
 * Will return a generated AST for a Styled Component.
 *
 * @param opts {StyledTemplateOpts} Template options
 * @param meta {Metadata} Useful metadata that can be used during the transformation
 */
const styledTemplate = (opts, meta) => {
    var _a, _b;
    const nonceAttribute = meta.state.opts.nonce ? `nonce={${meta.state.opts.nonce}}` : '';
    const styleProp = opts.variables.length
        ? styledStyleProp(opts.variables)
        : t.identifier(constants_1.STYLE_IDENTIFIER_NAME);
    const isInBuiltComponent = opts.tag.type === 'InBuiltComponent';
    // This completely depends on meta.parentPath to be the styled component.
    // If this changes please pass the component in another way
    const invalidDomProps = isInBuiltComponent ? getInvalidDomProps(meta.parentPath) : [];
    const hasInvalidDomProps = Boolean(invalidDomProps.length);
    let unconditionalClassNames = '', conditionalClassNames = '';
    opts.classNames.forEach((item) => {
        if (t.isStringLiteral(item)) {
            unconditionalClassNames += `${item.value} `;
        }
        else if (t.isLogicalExpression(item) || t.isConditionalExpression(item)) {
            conditionalClassNames += `${(0, generator_1.default)(item).code}, `;
        }
    });
    // Extract the component name from declaration
    // i.e. componentName is `FooBar` given `const FooBar = styled.div(...)`
    const componentName = (_b = (_a = meta.parentPath.parent) === null || _a === void 0 ? void 0 : _a.id) === null || _b === void 0 ? void 0 : _b.name;
    // Add componentClassName if `addComponentName` is enabled and on non-production environment
    const componentClassName = (0, utils_1.toBoolean)(meta.state.opts.addComponentName) &&
        process.env.NODE_ENV !== 'production' &&
        componentName
        ? `"c_${componentName}", `
        : '';
    const classNames = `${componentClassName}"${unconditionalClassNames.trim()}", ${conditionalClassNames}`;
    const isDevelopmentEnv = (!process.env.BABEL_ENV && !process.env.NODE_ENV) ||
        ['development', 'test'].includes(process.env.BABEL_ENV || '') ||
        ['development', 'test'].includes(process.env.NODE_ENV || '');
    return (0, template_1.default)(`
  forwardRef(({
    as: C = ${buildComponentTag(opts.tag)},
    style: ${constants_1.STYLE_IDENTIFIER_NAME},
    ...${constants_1.PROPS_IDENTIFIER_NAME}
  }, ${constants_1.REF_IDENTIFIER_NAME}) => {
    ${isDevelopmentEnv
        ? `if (${constants_1.PROPS_IDENTIFIER_NAME}.innerRef) {
          throw new Error("Please use 'ref' instead of 'innerRef'.")
        }`
        : ''}
    ${hasInvalidDomProps
        ? `const {${invalidDomProps.join(', ')}, ...${constants_1.DOM_PROPS_IDENTIFIER_NAME}} = ${constants_1.PROPS_IDENTIFIER_NAME};`
        : ''}

    return (
      <CC>
        <CS ${nonceAttribute}>{%%cssNode%%}</CS>
        <C
          {...${hasInvalidDomProps ? constants_1.DOM_PROPS_IDENTIFIER_NAME : constants_1.PROPS_IDENTIFIER_NAME}}
          style={%%styleProp%%}
          ref={${constants_1.REF_IDENTIFIER_NAME}}
          className={${(0, get_runtime_class_name_library_1.getRuntimeClassNameLibrary)(meta)}([${classNames} ${constants_1.PROPS_IDENTIFIER_NAME}.className])}
        />
      </CC>
    );
  });
`, {
        plugins: ['jsx'],
    })({
        styleProp,
        cssNode: t.arrayExpression((0, utils_1.unique)(opts.sheets).map((sheet) => (0, hoist_sheet_1.hoistSheet)(sheet, meta))),
    });
};
/**
 * Find CSS selectors that are apart of incomplete closures
 * i.e. `:hover {`
 *
 * @param css {string} Template options
 */
const findOpenSelectors = (css) => {
    // Remove any occurrence of { or } inside quotes to stop them
    // interfering with closure matches
    let searchArea = css.replace(/['|"].*[{|}].*['|"]/g, '');
    // Skip over complete closures
    searchArea = searchArea.substring(searchArea.lastIndexOf('}') + 1);
    // Regex for CSS selector
    //[^;\s] Don't match ; or whitespace
    // .+\n?{ Match anything (the selector itself) followed by any newlines then {
    return searchArea.match(/[^;\s].+\n?{/g);
};
/**
 * Returns a Styled Component AST.
 *
 * @param tag {Tag} Styled tag either an inbuilt or user define
 * @param cssOutput {CSSOutput} CSS and variables to place onto the component
 * @param meta {Metadata} Useful metadata that can be used during the transformation
 */
const buildStyledComponent = (tag, cssOutput, meta) => {
    let unconditionalCss = '';
    const conditionalCssItems = [];
    cssOutput.css.forEach((item) => {
        if (item.type === 'logical' || item.type === 'conditional') {
            // TODO: Optimize this to only run if there is a
            // potential selector scope change
            const selectors = findOpenSelectors(unconditionalCss);
            if (selectors) {
                (0, transform_css_items_1.applySelectors)(item, selectors);
            }
            conditionalCssItems.push(item);
        }
        else {
            unconditionalCss += (0, css_builders_1.getItemCss)(item);
        }
    });
    // Rely on transformCss to remove duplicates and return only the last unconditional CSS for each property
    const uniqueUnconditionalCssOutput = (0, css_1.transformCss)(unconditionalCss, meta.state.opts);
    // Rely on transformItemCss to build expressions for conditional & logical CSS
    const conditionalCssOutput = (0, transform_css_items_1.transformCssItems)(conditionalCssItems, meta);
    const sheets = [...uniqueUnconditionalCssOutput.sheets, ...conditionalCssOutput.sheets];
    const classNames = [
        ...[
            t.stringLiteral((0, compress_class_names_for_runtime_1.compressClassNamesForRuntime)(uniqueUnconditionalCssOutput.classNames, meta.state.opts.classNameCompressionMap).join(' ')),
        ],
        ...conditionalCssOutput.classNames,
    ];
    return styledTemplate({
        classNames,
        tag,
        sheets,
        variables: cssOutput.variables,
    }, meta);
};
exports.buildStyledComponent = buildStyledComponent;
//# sourceMappingURL=build-styled-component.js.map