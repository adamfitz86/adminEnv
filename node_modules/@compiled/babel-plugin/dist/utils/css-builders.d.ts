import * as t from '@babel/types';
import type { Metadata } from '../types';
import type { CSSOutput, CssItem } from './types';
/**
 * Returns the item css.
 *
 * @param item
 */
export declare const getItemCss: (item: CssItem) => string;
/**
 * If we don't yet have a `meta.state.cssMap[node.name]` built yet, try to build and cache it, eg. in this scenario:
 * ```tsx
 * const Component = () => <div css={styles.root} />
 * const styles = cssMap({ root: { padding: 0 } });
 * ```
 *
 * If we don't find this is a `cssMap()` call, we put it into `ignoreMemberExpressions` to ignore on future runs.
 *
 * @returns {Boolean} Whether the cache was generated
 */
export declare const generateCacheForCSSMap: (node: t.Identifier, meta: Metadata) => void;
/**
 * Internal functionality to return a CSS string and CSS variables array from an input node.
 *
 * @param node Node we're interested in extracting CSS from.
 * @param meta {Metadata} Useful metadata that can be used during the transformation
 */
export declare const buildCssInternal: (node: t.Expression | t.Expression[], meta: Metadata) => CSSOutput;
/**
 * Will return a CSS string and CSS variables array from an input node.
 *
 * This includes some top-level error handling for invalid CSS combinations.
 *
 * @param node Node we're interested in extracting CSS from.
 * @param meta {Metadata} Useful metadata that can be used during the transformation
 */
export declare const buildCss: (node: t.Expression | t.Expression[], meta: Metadata) => CSSOutput;
