"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.objectPropertyToString = exports.expressionToString = exports.canBeStaticallyConcatenated = void 0;
const t = __importStar(require("@babel/types"));
const evaluate_expression_1 = require("./evaluate-expression");
const templateLiteralToString = (template, meta, expressionToString) => {
    let result = '';
    for (let i = 0; i < template.quasis.length; i += 1) {
        result += template.quasis[i].value.raw;
        if (i < template.expressions.length) {
            const expression = template.expressions[i];
            if (t.isTSType(expression)) {
                // Passed a type instead of a value
                // e.g. `${any}`
                throw new Error(`${template.type} has a type instead of a value`);
            }
            const evaluatedExpression = (0, evaluate_expression_1.evaluateExpression)(expression, meta);
            result += expressionToString(evaluatedExpression.value, evaluatedExpression.meta);
        }
    }
    return result;
};
const binaryExpressionToString = (expression, meta, expressionToString) => {
    const { left, right, operator } = expression;
    if (operator === '+' && t.isExpression(left)) {
        const leftValue = expressionToString(left, meta);
        const rightValue = expressionToString(right, meta);
        return `${leftValue}${rightValue}`;
    }
    throw new Error(`Cannot use ${operator} for string operation. Use + for string concatenation`);
};
const isStringConcatExpression = (expression) => {
    var _a;
    if (!t.isCallExpression(expression))
        return false;
    const callee = expression.callee;
    if (t.isMemberExpression(callee) &&
        callee.computed === false &&
        t.isStringLiteral(callee.object) &&
        t.isIdentifier(callee.property) &&
        callee.property.name === 'concat' &&
        typeof ((_a = expression.arguments) === null || _a === void 0 ? void 0 : _a.length) === 'number') {
        return true;
    }
    return false;
};
/**
 * Determines if we think we can deeply and statically concatenate the arguments of a `"text ".concat('…')` call.
 *
 * For example, `"8px ".concat(' var(--ds-space-050)', ' var(--ds-space-100)')` might be output
 * by Babel and statically concatenated to `"8px var(--ds-space-050) var(--ds-space-100)"`.
 */
const canBeStaticallyConcatenated = (expression) => {
    if (!isStringConcatExpression(expression))
        return false;
    const args = expression.arguments;
    if (!args.length)
        return true;
    // We only attempt to statically concatenate these specific arguments (though more types may be viable)
    return args.every((arg) => {
        // Example: `'b`' in `"a".concat('b', 'c')``
        if (t.isStringLiteral(arg) || t.isNumericLiteral(arg))
            return true;
        // Example: `${b}` in `"a".concat(`${b}`, 'c')` where `b` is static, eg. `const b = 'b'`
        if (t.isTemplateLiteral(arg))
            return true;
        return false;
    });
};
exports.canBeStaticallyConcatenated = canBeStaticallyConcatenated;
/**
 * Attempts to statically concatenate the arguments of a `"text ".concat('…')` call.
 *
 * For example, `"8px ".concat(' var(--ds-space-050)', ' var(--ds-space-100)')` might be output
 * by Babel and this will statically concatenate it to `"8px var(--ds-space-050) var(--ds-space-100)"`.
 */
const concatToString = (expression, meta, expressionToString) => {
    const callee = expression.callee;
    const args = expression.arguments;
    if (!args.length)
        return callee.object.value;
    return args.reduce((acc, arg) => {
        if (!t.isExpression(arg)) {
            // NOTE: We cannot concatenate this expression, however `canBeStaticallyConcatenated(…)` should catch this.
            throw new Error(`Cannot concatenate an expression with non-expression arguments`);
        }
        return acc + expressionToString(arg, meta);
    }, callee.object.value);
};
const expressionToString = (expression, meta) => {
    // handles {'key-name': 'value'} or {1: 'value'}
    if (t.isStringLiteral(expression) || t.isNumericLiteral(expression)) {
        return String(expression.value);
    }
    // handles {[key]: 'value'} and {[key.key]: 'value'}]}
    if (t.isIdentifier(expression) || t.isMemberExpression(expression)) {
        const evaluatedExpression = (0, evaluate_expression_1.evaluateExpression)(expression, meta);
        if (evaluatedExpression.value === expression) {
            throw new Error(`Cannot statically evaluate the value of "${t.isIdentifier(expression) ? expression.name : expression.type}`);
        }
        return (0, exports.expressionToString)(evaluatedExpression.value, evaluatedExpression.meta);
    }
    // handles {[`key-${name}`]: 'value'}
    if (t.isTemplateLiteral(expression)) {
        return templateLiteralToString(expression, meta, exports.expressionToString);
    }
    // handles {['key-' + name]: 'value'}
    if (t.isBinaryExpression(expression)) {
        return binaryExpressionToString(expression, meta, exports.expressionToString);
    }
    if (t.isCallExpression(expression) && (0, exports.canBeStaticallyConcatenated)(expression)) {
        return concatToString(expression, meta, exports.expressionToString);
    }
    throw new Error(`${expression.type} has no name.'`);
};
exports.expressionToString = expressionToString;
/**
 * Returns string output of a ObjectProperty's key
 *
 * @param prop ObjectProperty expression
 * @param meta Metadata
 */
const objectPropertyToString = (prop, meta) => {
    const { computed, key } = prop;
    // handles {key: 'value'}
    if (t.isIdentifier(key) && !computed) {
        return key.name;
    }
    return (0, exports.expressionToString)(key, meta);
};
exports.objectPropertyToString = objectPropertyToString;
//# sourceMappingURL=object-property-to-string.js.map