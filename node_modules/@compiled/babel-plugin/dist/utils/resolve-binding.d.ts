import * as t from '@babel/types';
import type { Metadata } from '../types';
import type { PartialBindingWithMeta, EvaluateExpression } from './types';
/**
 * Will recursively checks if identifier name is coming from destructuring. If yes,
 * then will return the resolved identifier. We can look for identifier name
 * either in destructuring key or its value.
 *
 * @param name Identifier name to resolve
 * @param node Any Expression node
 * @param resolveFor Either resolve destructuring key or its value
 */
export declare const resolveIdentifierComingFromDestructuring: ({ name, node, resolveFor, }: {
    name: string;
    node: t.Expression | undefined;
    resolveFor?: "value" | "key" | undefined;
}) => t.ObjectProperty | undefined;
/**
 * Will return the `node` of the a binding.
 * This function will follow import specifiers to return the actual `node`.
 *
 * When wanting to do further traversal on the resulting `node` make sure to use the output `meta` as well.
 * The `meta` will be for the resulting file it was found in.
 *
 * @param referenceName {string} Reference name for which `binding` to be resolved
 * @param meta {Metadata} Useful metadata that can be used during the transformation
 */
export declare const resolveBinding: (referenceName: string, meta: Metadata, evaluateExpression: EvaluateExpression) => PartialBindingWithMeta | undefined;
