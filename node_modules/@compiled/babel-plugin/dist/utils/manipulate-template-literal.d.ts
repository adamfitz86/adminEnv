import * as t from '@babel/types';
import type { Metadata } from '../types';
/**
 * TODO: this is a temporary workaround so that we don't evaluate expressions that may throw an error.
 * It should be removed after addressing https://github.com/atlassian-labs/compiled/issues/1081
 *
 * Returns `true` if
 * - there is another conditional expression at the root of the current template literal
 *   with a conditional expression to evaluate OR
 * - there is a nested logical expression within the current template literal
 *
 * @param node
 * @param meta {Metadata} The current metadata to use to find the parent node
 */
export declare const hasNestedTemplateLiteralsWithConditionalRules: (node: t.TemplateLiteral, meta: Metadata) => boolean;
export declare const recomposeTemplateLiteral: (template: t.TemplateLiteral, prefix: string, suffix?: string) => void;
/**
 * Tries to modify a CSS statement in a template literal containing conditional values to
 * output separate CSS classes for each value
 * @param quasi {t.TemplateElement}
 * @param nextQuasi {t.TemplateElement}
 * @param expression {t.ArrowFunctionExpression}
 */
export declare const optimizeConditionalStatement: (quasi: t.TemplateElement, nextQuasi: t.TemplateElement, expression: t.ArrowFunctionExpression) => void;
/**
 * Checks if quasi ends in an incomplete statement
 * @param quasi {t.TemplateElement}
 */
export declare const isQuasiMidStatement: (quasi: t.TemplateElement) => boolean;
