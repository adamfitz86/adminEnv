"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.visitClassNamesPath = void 0;
const t = __importStar(require("@babel/types"));
const ast_1 = require("../utils/ast");
const build_compiled_component_1 = require("../utils/build-compiled-component");
const build_css_variables_1 = require("../utils/build-css-variables");
const css_builders_1 = require("../utils/css-builders");
const get_runtime_class_name_library_1 = require("../utils/get-runtime-class-name-library");
const resolve_binding_1 = require("../utils/resolve-binding");
const transform_css_items_1 = require("../utils/transform-css-items");
/**
 * Handles style prop value. If variables are present it will replace its value with it
 * otherwise will add undefined.
 *
 * @param variables CSS variables prop to be placed as inline styles
 * @param path Any Expression path
 */
const handleStyleProp = (variables, path) => {
    const styleValue = variables.length
        ? t.objectExpression((0, build_css_variables_1.buildCssVariables)(variables))
        : t.identifier('undefined');
    path.replaceWith(styleValue);
};
/**
 * Extracts styles from an expression.
 *
 * @param path Expression node
 */
const extractStyles = (path) => {
    var _a;
    if (t.isCallExpression(path.node) &&
        t.isIdentifier(path.node.callee) &&
        path.node.callee.name === 'css' &&
        t.isExpression(path.node.arguments[0])) {
        // css({}) call
        const styles = path.node.arguments;
        return styles;
    }
    if (t.isCallExpression(path.node) &&
        t.isIdentifier(path.node.callee) &&
        t.isExpression(path.node.arguments[0]) &&
        path.scope.hasOwnBinding(path.node.callee.name)) {
        const binding = (_a = path.scope.getBinding(path.node.callee.name)) === null || _a === void 0 ? void 0 : _a.path.node;
        if (!!(0, resolve_binding_1.resolveIdentifierComingFromDestructuring)({ name: 'css', node: binding })) {
            // c({}) rename call
            const styles = path.node.arguments;
            return styles;
        }
    }
    if (t.isCallExpression(path.node) && t.isMemberExpression(path.node.callee)) {
        if (t.isIdentifier(path.node.callee.property) &&
            path.node.callee.property.name === 'css' &&
            t.isExpression(path.node.arguments[0])) {
            // props.css({}) call
            const styles = path.node.arguments;
            return styles;
        }
    }
    if (t.isTaggedTemplateExpression(path.node)) {
        const styles = path.node.quasi;
        return styles;
    }
    return undefined;
};
/**
 * Returns the children of a children as function expression.
 * Will throw if no children as function was found.
 *
 * @param path
 */
const getJsxChildrenAsFunction = (path) => {
    const children = path.node.children.find((node) => t.isJSXExpressionContainer(node));
    if (t.isJSXExpressionContainer(children) && t.isFunction(children.expression)) {
        return children.expression;
    }
    throw (0, ast_1.buildCodeFrameError)(`ClassNames children should be a function
E.g: <ClassNames>{props => <div />}</ClassNames>`, path.node, path);
};
/**
 * Takes a class name component and transforms it into a compiled component.
 * This method will traverse the AST twice,
 * once to replace all calls to `css`,
 * and another to replace `style` usage.
 *
 * `<ClassNames>{}</ClassNames>`
 *
 * @param path {NodePath} The opening JSX element
 * @param meta {Metadata} Useful metadata that can be used during the transformation
 */
const visitClassNamesPath = (path, meta) => {
    var _a, _b;
    if (t.isJSXIdentifier(path.node.openingElement.name) &&
        !((_b = (_a = meta.state.compiledImports) === null || _a === void 0 ? void 0 : _a.ClassNames) === null || _b === void 0 ? void 0 : _b.includes(path.node.openingElement.name.name))) {
        // We aren't interested in this element. Bail out!
        return;
    }
    const collectedVariables = [];
    const collectedSheets = [];
    // First pass to replace all usages of `css({})`
    path.traverse({
        Expression(path) {
            const styles = extractStyles(path);
            if (!styles) {
                // Nothing to do - skip.
                return;
            }
            const builtCss = (0, css_builders_1.buildCss)(styles, meta);
            const { sheets, classNames } = (0, transform_css_items_1.transformCssItems)(builtCss.css, meta);
            collectedVariables.push(...builtCss.variables);
            collectedSheets.push(...sheets);
            path.replaceWith(t.callExpression(t.identifier((0, get_runtime_class_name_library_1.getRuntimeClassNameLibrary)(meta)), [
                t.arrayExpression(classNames),
            ]));
        },
    });
    // Second pass to replace all usages of `style`.
    path.traverse({
        Expression(path) {
            var _a;
            if (t.isIdentifier(path.node)) {
                if (path.parentPath.isProperty()) {
                    return;
                }
                // style={style}
                if (path.node.name === 'style' && path.scope.hasOwnBinding('style')) {
                    handleStyleProp(collectedVariables, path);
                }
                // style={styl} rename prop
                if (path.scope.hasOwnBinding(path.node.name)) {
                    const binding = (_a = path.scope.getBinding(path.node.name)) === null || _a === void 0 ? void 0 : _a.path.node;
                    if (!!(0, resolve_binding_1.resolveIdentifierComingFromDestructuring)({
                        name: 'style',
                        node: binding,
                    })) {
                        handleStyleProp(collectedVariables, path);
                    }
                }
            }
            else if (t.isMemberExpression(path.node)) {
                // filter out invalid calls like dontexist.style
                if (t.isIdentifier(path.node.object) && !path.scope.hasOwnBinding(path.node.object.name)) {
                    return;
                }
                // style={props.style}
                if (t.isIdentifier(path.node.property) && path.node.property.name === 'style') {
                    handleStyleProp(collectedVariables, path);
                }
            }
        },
    });
    // All done! Pick the children as function body and replace the original ClassNames node with it.
    const children = getJsxChildrenAsFunction(path);
    const body = (0, ast_1.pickFunctionBody)(children);
    path.replaceWith((0, build_compiled_component_1.compiledTemplate)(body, collectedSheets, meta));
};
exports.visitClassNamesPath = visitClassNamesPath;
//# sourceMappingURL=index.js.map