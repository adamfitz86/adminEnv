"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const core_1 = require("@babel/core");
const generator_1 = __importDefault(require("@babel/generator"));
const utils_1 = require("@compiled/utils");
const plugin_1 = require("@parcel/plugin");
const source_map_1 = __importDefault(require("@parcel/source-map"));
// @ts-expect-error missing type
const utils_2 = require("@parcel/utils");
const utils_3 = require("./utils");
const configFiles = [
    '.compiledcssrc',
    '.compiledcssrc.json',
    'compiledcss.js',
    'compiledcss.config.js',
];
const packageKey = '@compiled/parcel-transformer';
/**
 * Compiled parcel transformer.
 */
exports.default = new plugin_1.Transformer({
    async loadConfig({ config, options }) {
        const conf = await config.getConfigFrom((0, path_1.join)(options.projectRoot, 'index'), configFiles, {
            packageKey,
        });
        const contents = {
            extract: false,
            importReact: true,
            ssr: false,
        };
        if (conf) {
            if (conf.filePath.endsWith('.js')) {
                config.invalidateOnStartup();
            }
            // Use `classNameCompressionMapFilePath` to get classNameCompressionMap
            // Note `classNameCompressionMap` and `classNameCompressionMapFilePath` are mutually exclusive.
            // If both are provided, classNameCompressionMap takes precedence.
            if (!conf.contents.classNameCompressionMap && conf.contents.classNameCompressionMapFilePath) {
                // Use `getConfigFrom` from Parcel so the contents are cached at `.parcel-cache`
                const configClassNameCompressionMap = await config.getConfigFrom((0, path_1.join)(options.projectRoot, 'index'), [conf.contents.classNameCompressionMapFilePath], {
                    packageKey,
                });
                if (configClassNameCompressionMap === null || configClassNameCompressionMap === void 0 ? void 0 : configClassNameCompressionMap.contents) {
                    Object.assign(contents, {
                        classNameCompressionMap: configClassNameCompressionMap === null || configClassNameCompressionMap === void 0 ? void 0 : configClassNameCompressionMap.contents,
                    });
                }
            }
            Object.assign(contents, conf.contents);
        }
        return contents;
    },
    canReuseAST() {
        // Compiled should run before any other JS transformer.
        return false;
    },
    async parse({ asset, config, options }) {
        var _a, _b;
        // Disable stylesheet extraction locally due to https://github.com/atlassian-labs/compiled/issues/1306
        const extract = config.extract && options.mode !== 'development';
        if (!asset.isSource && !extract) {
            // Only parse source (pre-built code should already have been baked) or if stylesheet extraction is enabled
            return undefined;
        }
        const code = await asset.getCode();
        if (
        // If neither Compiled (default) nor any of the additional import sources are found in the code, we bail out.
        [...utils_1.DEFAULT_IMPORT_SOURCES, ...(config.importSources || [])].every((importSource) => !code.includes(importSource))) {
            // We only want to parse files that are actually using Compiled.
            // For everything else we bail out.
            return undefined;
        }
        const program = await (0, core_1.parseAsync)(code, {
            filename: asset.filePath,
            babelrc: false,
            configFile: false,
            caller: { name: 'compiled' },
            rootMode: 'upward-optional',
            parserOpts: {
                plugins: (_a = config.parserBabelPlugins) !== null && _a !== void 0 ? _a : utils_1.DEFAULT_PARSER_BABEL_PLUGINS,
            },
            plugins: (_b = config.transformerBabelPlugins) !== null && _b !== void 0 ? _b : undefined,
        });
        if (program) {
            return {
                type: 'babel',
                version: '7.0.0',
                program,
            };
        }
        return undefined;
    },
    async transform({ asset, config, options }) {
        var _a, _b, _c, _d, _e;
        if (config.extract && config.classHashPrefix) {
            throw new Error('`@compiled/parcel-transformer` is mixing `extract: true` and `classHashPrefix` options, which will not supported and will result in bundle size bloat.');
        }
        const ast = await asset.getAST();
        if (!((ast === null || ast === void 0 ? void 0 : ast.type) === 'babel' && ast.program)) {
            // We will only receive ASTs for assets we're interested in.
            // Since this is undefined (or in node modules) we aren't interested in it.
            return [asset];
        }
        // Disable stylesheet extraction locally due to https://github.com/atlassian-labs/compiled/issues/1306
        const extract = config.extract && options.mode !== 'development';
        const includedFiles = [];
        const code = asset.isASTDirty() ? undefined : await asset.getCode();
        const result = await (0, core_1.transformFromAstAsync)(ast.program, code, {
            code: false,
            ast: true,
            filename: asset.filePath,
            babelrc: false,
            configFile: false,
            sourceMaps: !!asset.env.sourceMap,
            compact: false,
            parserOpts: {
                plugins: (_a = config.parserBabelPlugins) !== null && _a !== void 0 ? _a : utils_1.DEFAULT_PARSER_BABEL_PLUGINS,
            },
            plugins: [
                ...((_b = config.transformerBabelPlugins) !== null && _b !== void 0 ? _b : []),
                asset.isSource && [
                    '@compiled/babel-plugin',
                    Object.assign(Object.assign({}, config), { classNameCompressionMap: config.extract && config.classNameCompressionMap, onIncludedFiles: (files) => includedFiles.push(...files), resolver: config.resolver ? config.resolver : (0, utils_3.createDefaultResolver)(config), cache: false }),
                ],
                extract && [
                    '@compiled/babel-plugin-strip-runtime',
                    {
                        compiledRequireExclude: true,
                        extractStylesToDirectory: config.extractStylesToDirectory,
                    },
                ],
            ].filter(utils_1.toBoolean),
            caller: {
                name: 'compiled',
            },
        });
        includedFiles.forEach((file) => {
            // Included files are those which have been statically evaluated into this asset.
            // This tells parcel that if any of those files change this asset should be transformed
            // again.
            asset.invalidateOnFileChange(file);
        });
        if (extract) {
            // Store styleRules to asset.meta to be used by @compiled/parcel-optimizer
            const metadata = result === null || result === void 0 ? void 0 : result.metadata;
            asset.meta.styleRules = [
                ...((_d = (_c = asset.meta) === null || _c === void 0 ? void 0 : _c.styleRules) !== null && _d !== void 0 ? _d : []),
                ...((_e = metadata.styleRules) !== null && _e !== void 0 ? _e : []),
            ];
        }
        if (result === null || result === void 0 ? void 0 : result.ast) {
            asset.setAST({
                type: 'babel',
                version: '7.0.0',
                program: result.ast,
            });
        }
        return [asset];
    },
    async generate({ asset, ast, options }) {
        const originalSourceMap = await asset.getMap();
        const sourceFileName = (0, utils_2.relativeUrl)(options.projectRoot, asset.filePath);
        // @ts-expect-error RawMappings should exist here
        const { code, rawMappings } = (0, generator_1.default)(ast.program, {
            sourceFileName,
            sourceMaps: !!asset.env.sourceMap,
            comments: true,
        });
        const map = new source_map_1.default(options.projectRoot);
        if (rawMappings) {
            map.addIndexedMappings(rawMappings);
        }
        if (originalSourceMap) {
            // The babel AST already contains the correct mappings, but not the source contents.
            // We need to copy over the source contents from the original map.
            // @ts-expect-error getSourcesContentMap exists
            const sourcesContent = originalSourceMap.getSourcesContentMap();
            for (const filePath in sourcesContent) {
                const content = sourcesContent[filePath];
                if (content != null) {
                    map.setSourceContent(filePath, content);
                }
            }
        }
        return {
            content: code,
            map,
        };
    },
});
//# sourceMappingURL=index.js.map